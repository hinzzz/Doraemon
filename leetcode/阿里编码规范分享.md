### 一、集合处理

#### 1、[强制]为什么要求谨慎使用 ArrayList 中的 subList 方法？  

> **[ 强制]** Arraylist的subList结果不可强转成ArrayList,否则会抛出ClassCastException异常，即java. util. RandomAccessSubList cannot be cast to java. util. ArrayList.说明: subList 返回的是ArrayList 的内部类SubList， 并不是ArrayList ，而是Arraylist的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。

##### 1、ArrayList.subList()

```java
@Test
    public void subList(){
        List<String> names = new ArrayList<String>() {{
            add("aa");
            add("bb");
            add("cc");
        }};

        List subList = names.subList(0, 1);
        System.out.println(subList);

        ArrayList subList1 = (ArrayList) names.subList(0, 1);//抛异常
        System.out.println(subList);
    }
```

抛出异常

```java
java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList
```

##### 2、原因

实际上返回的是SubList，ArrayList的一个内部类，把原来list的属性赋值给了自己，SubList和ArrayList并没有继承或者实现关系，不能进行类型的强转

```java\
public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }
    
private class SubList extends AbstractList<E> implements RandomAccess {
		SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }
}
```



##### 3、对subList的结果集进行操作

```java
/**
* 对结果集进行操作
*/
@Test
public void subListEdit(){
    List<String> names = new ArrayList<String>() {{
        add("11");
        add("22");
        add("33");
    }};

    List subList = names.subList(0, 2);
    System.out.println(subList);
    subList.add("44");
    System.out.println("subList = " + subList);
    System.out.println("names = " + names);
}
```

这里我们对subList的结果追加了元素，得到的结果是原生list和subList结果集都发生了变化 

```java
[11, 22]
subList = [11, 22, 44]
names = [11, 22, 44, 33]
```

#### 2、[强制]在sublist场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException异常。

##### 1、对原list进行操作

```java
/**
     * 对原list进行操作
     */
    @Test
    public void sourceListEdit(){
        List<String> sourceList = new ArrayList<String>() {{
            add("11");
            add("22");
            add("33");
        }};

        List subList = sourceList.subList(0, 2);
        System.out.println(subList);
        sourceList.add("44");
        System.out.println("subList = " + subList);
        System.out.println("names = " + sourceList);
    }
```

![image-20210914154149596](http://hinzzz.oss-cn-shenzhen.aliyuncs.com/img/hinzzzimage-20210914154149596.png)

##### 2、原因

如果对原list进行操作，原list的modCount会发生改变（这里由3>4），而subList的modCount还是原来的3,进行迭代器输出的时候会抛出异常

```java
 private void checkForComodification() {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
        }
```



### 二、异常处理

#### 1、【强制】 Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避

> 【强制】 Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该
> 通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。
> 说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch
> NumberFormatException 来实现。
> 正例： if (obj != null) {...}
> 反例： try { obj.method() } catch (NullPointerException e) {...}









### 三、并发处理

#### 1、【强制】 高并发时， 同步调用应该去考量锁的性能损耗。 能用无锁数据结构，
就不要用锁； 能锁区块， 就不要锁整个方法体； 能用对象锁， 就不要用类锁。  

##### 1、无锁数据结构

> ​	不使用锁就能实现安全并发存取的数据结构被称为无锁数据结构。








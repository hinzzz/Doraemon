#### 一、集合处理

#### 1、为什么要求谨慎使用 ArrayList 中的 subList 方法？  

> **[ 强制]** Arraylist的subList结果不可强转成ArrayList,否则会抛出ClassCastException异常，即java. util. RandomAccessSubList cannot be cast to java. util. ArrayList.说明: subList 返回的是ArrayList 的内部类SubList， 并不是ArrayList ，而是Arraylist的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。

##### 1、ArrayList.subList()

```java
@Test
    public void subList(){
        List<String> names = new ArrayList<String>() {{
            add("aa");
            add("bb");
            add("cc");
        }};

        List subList = names.subList(0, 1);
        System.out.println(subList);

        ArrayList subList1 = (ArrayList) names.subList(0, 1);//抛异常
        System.out.println(subList);
    }
```

抛出异常

```java
java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList
```

##### 2、原因

实际上返回的是SubList，ArrayList的一个内部类，把原来list的属性赋值给了自己，SubList和ArrayList并没有继承或者实现关系，不能进行类型的强转

```java\
public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }
    
private class SubList extends AbstractList<E> implements RandomAccess {
		SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }
}
```



##### 3、对subList的结果集进行操作

```java
/**
* 对结果集进行操作
*/
@Test
public void subListEdit(){
    List<String> names = new ArrayList<String>() {{
        add("11");
        add("22");
        add("33");
    }};

    List subList = names.subList(0, 2);
    System.out.println(subList);
    subList.add("44");
    System.out.println("subList = " + subList);
    System.out.println("names = " + names);
}
```

这里我们对subList的结果追加了元素，得到的结果是原生list和subList结果集都发生了变化 

